import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { sql } from '@/lib/db';

// Type definitions
interface RouteParams {
  profile?: string;
  includeService?: boolean;
  chunkDuration?: number;
  jobId?: string;
  status?: string;
  createdAt?: string;
  completedAt?: string;
  progress?: number;
}

// Request validation schema
const GenerateRouteSchema = z.object({
  areaId: z.string().uuid('Invalid area ID'),
  chunkDuration: z.number().min(600).max(7200).default(3600),
});

export async function POST(req: NextRequest) {
  try {
    // Parse and validate request body
    const body = await req.json();
    const validatedData = GenerateRouteSchema.parse(body);

    // Fetch area details from database
    const areaResult = await sql`
      SELECT 
        id, 
        name, 
        ST_AsGeoJSON(geom) as geojson,
        buffer_m,
        params
      FROM areas 
      WHERE id = ${validatedData.areaId}
    `;

    if (!areaResult || areaResult.length === 0) {
      return NextResponse.json(
        { error: 'Area not found' },
        { status: 404 }
      );
    }

    const area = areaResult[0];
    const params = area.params as RouteParams;
    
    // For now, create a simple mock route generation
    // In production, this would:
    // 1. Queue a job to fetch OSM street data
    // 2. Run Chinese Postman algorithm
    // 3. Generate optimal coverage route
    // 4. Split into chunks based on duration
    
    // Create a mock job ID
    const jobId = `job_${Date.now()}_${area.id.substring(0, 8)}`;
    
    // Insert a job record for the worker to pick up
    const routeResult = await sql`
      INSERT INTO coverage_routes (
        area_id,
        area_name,
        profile,
        status,
        progress,
        length_m,
        drive_time_s,
        params,
        metadata,
        geom
      ) VALUES (
        ${validatedData.areaId},
        ${area.name},
        ${params?.profile || 'driving-car'},
        'queued',
        0,
        ${0}, -- Will be calculated by worker
        ${0}, -- Will be calculated by worker
        ${JSON.stringify({
          chunkDuration: validatedData.chunkDuration,
          includeService: params?.includeService || false
        })}::jsonb,
        ${JSON.stringify({
          jobId: jobId,
          createdAt: new Date().toISOString()
        })}::jsonb,
        NULL -- Will be generated by worker
      )
      RETURNING id, area_id, area_name, status, profile, created_at
    `;

    if (!routeResult || routeResult.length === 0) {
      throw new Error('Failed to create route record');
    }

    const route = routeResult[0];
    
    // TODO: Queue job to worker service
    // For now, we'll simulate the job being queued
    console.log('Route generation job queued:', {
      jobId,
      areaId: area.id,
      areaName: area.name,
      routeId: route.id,
      chunkDuration: validatedData.chunkDuration
    });

    return NextResponse.json({
      success: true,
      jobId: jobId,
      routeId: route.id,
      message: `Route generation started for ${area.name}`,
      details: {
        areaName: area.name,
        profile: params?.profile || 'driving-car',
        chunkDuration: validatedData.chunkDuration,
        estimatedTime: 'Processing...'
      }
    });
  } catch (error) {
    console.error('Generate route error:', error);

    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Validation error', details: error.issues },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { error: 'Failed to generate route', details: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    );
  }
}

// GET endpoint to check job status
export async function GET(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url);
    const jobId = searchParams.get('jobId');
    
    if (!jobId) {
      // Return all recent jobs
      const routes = await sql`
        SELECT 
          r.id,
          r.area_id,
          a.name as area_name,
          r.profile,
          r.length_m,
          r.drive_time_s,
          r.params,
          r.created_at
        FROM coverage_routes r
        JOIN areas a ON a.id = r.area_id
        ORDER BY r.created_at DESC
        LIMIT 10
      `;

      return NextResponse.json({
        success: true,
        routes: routes.map(r => ({
          id: r.id,
          areaId: r.area_id,
          areaName: r.area_name,
          profile: r.profile,
          lengthM: r.length_m,
          driveTimeS: r.drive_time_s,
          status: (r.params as RouteParams)?.status || 'completed',
          jobId: (r.params as RouteParams)?.jobId,
          createdAt: r.created_at
        }))
      });
    }

    // Check specific job status
    const routes = await sql`
      SELECT 
        r.*,
        a.name as area_name
      FROM coverage_routes r
      JOIN areas a ON a.id = r.area_id
      WHERE r.params->>'jobId' = ${jobId}
    `;

    if (!routes || routes.length === 0) {
      return NextResponse.json(
        { error: 'Job not found' },
        { status: 404 }
      );
    }

    const route = routes[0];
    const params = route.params as RouteParams;

    return NextResponse.json({
      success: true,
      job: {
        id: params.jobId,
        routeId: route.id,
        areaName: route.area_name,
        status: params.status || 'processing',
        progress: params.progress || 0,
        createdAt: params.createdAt,
        completedAt: params.completedAt
      }
    });
  } catch (error) {
    console.error('Get job status error:', error);
    return NextResponse.json(
      { error: 'Failed to get job status' },
      { status: 500 }
    );
  }
}