import { NextRequest, NextResponse } from 'next/server';
import { neon } from '@neondatabase/serverless';

interface RouteData {
  area_name: string;
  length_m?: number;
  drive_time_s?: number;
  geojson?: {
    type: string;
    coordinates: number[][] | number[][][];
  };
}

interface ChunkData {
  geojson?: {
    type: string;
    coordinates: number[][];
  };
}

function generateGPX(route: RouteData, chunks: ChunkData[]): string {
  const now = new Date().toISOString();

  let gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="ScanNeo Router" 
     xmlns="http://www.topografix.com/GPX/1/1"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">
  <metadata>
    <name>${route.area_name} Coverage Route</name>
    <desc>Generated by ScanNeo Router</desc>
    <time>${now}</time>
  </metadata>
  <trk>
    <name>${route.area_name} Coverage Route</name>
    <desc>Total distance: ${((route.length_m || 0) / 1000).toFixed(1)} km, Estimated time: ${((route.drive_time_s || 0) / 3600).toFixed(1)} hours</desc>
`;

  // Add track segments for each chunk
  if (chunks && chunks.length > 0) {
    chunks.forEach((chunk, index) => {
      gpx += `    <trkseg>\n`;
      gpx += `      <name>Chunk ${index + 1}</name>\n`;

      if (chunk.geojson && chunk.geojson.type === 'LineString') {
        const coordinates = chunk.geojson.coordinates as number[][];
        coordinates.forEach((coord) => {
          gpx += `      <trkpt lat="${coord[1]}" lon="${coord[0]}"></trkpt>\n`;
        });
      }

      gpx += `    </trkseg>\n`;
    });
  } else if (route.geojson) {
    // If no chunks, use the main route geometry
    gpx += `    <trkseg>\n`;

    if (route.geojson.type === 'LineString') {
      const coordinates = route.geojson.coordinates as number[][];
      coordinates.forEach((coord) => {
        gpx += `      <trkpt lat="${coord[1]}" lon="${coord[0]}"></trkpt>\n`;
      });
    } else if (route.geojson.type === 'MultiLineString') {
      const lines = route.geojson.coordinates as number[][][];
      lines.forEach((line) => {
        line.forEach((coord) => {
          gpx += `      <trkpt lat="${coord[1]}" lon="${coord[0]}"></trkpt>\n`;
        });
      });
    }

    gpx += `    </trkseg>\n`;
  }

  gpx += `  </trk>
</gpx>`;

  return gpx;
}

export async function GET(request: NextRequest, { params }: { params: Promise<{ id: string }> }) {
  const { id } = await params;
  const { searchParams } = new URL(request.url);
  const format = searchParams.get('format') || 'geojson';

  try {
    const sql = neon(process.env.DATABASE_URL!);

    // Fetch route details
    const route = await sql`
      SELECT 
        r.id,
        r.area_id,
        a.name as area_name,
        r.created_at,
        r.updated_at,
        r.profile,
        r.params,
        ST_AsGeoJSON(r.geom)::json as geojson,
        r.length_m,
        r.drive_time_s
      FROM coverage_routes r
      LEFT JOIN areas a ON r.area_id = a.id
      WHERE r.id = ${id}
      LIMIT 1
    `;

    if (route.length === 0) {
      return NextResponse.json({ error: 'Route not found' }, { status: 404 });
    }

    const routeData = route[0];

    // Fetch chunks if they exist
    let chunks: ChunkData[] = [];
    try {
      const chunkResults = await sql`
        SELECT 
          id,
          idx as chunk_index,
          ST_AsGeoJSON(geom)::json as geojson,
          length_m,
          time_s as duration_s
        FROM chunks
        WHERE route_id = ${id}
        ORDER BY idx
      `;
      chunks = chunkResults as ChunkData[];
    } catch (error) {
      // Chunks table might not exist
      console.warn('Could not fetch chunks:', error);
    }

    if (format === 'gpx') {
      // Generate GPX format
      const gpxContent = generateGPX(routeData as RouteData, chunks);

      return new NextResponse(gpxContent, {
        status: 200,
        headers: {
          'Content-Type': 'application/gpx+xml',
          'Content-Disposition': `attachment; filename="${routeData.area_name.replace(/\s+/g, '_')}_route.gpx"`,
        },
      });
    } else {
      // Default to GeoJSON format
      const geojsonData = {
        type: 'FeatureCollection',
        features: [
          {
            type: 'Feature',
            properties: {
              id: routeData.id,
              area_name: routeData.area_name,
              profile: routeData.profile,
              length_m: routeData.length_m,
              drive_time_s: routeData.drive_time_s,
              created_at: routeData.created_at,
              chunks: chunks.length,
            },
            geometry: routeData.geojson,
          },
        ],
      };

      // Add chunks as separate features if they exist
      if (chunks.length > 0) {
        chunks.forEach((chunk: ChunkData & { length_m?: number; duration_s?: number }, index) => {
          if (chunk.geojson) {
            geojsonData.features.push({
              type: 'Feature',
              properties: {
                chunk_index: index + 1,
                length_m: chunk.length_m || 0,
                duration_s: chunk.duration_s || 0,
                type: 'chunk',
              },
              geometry: chunk.geojson,
            } as unknown as (typeof geojsonData.features)[0]);
          }
        });
      }

      return new NextResponse(JSON.stringify(geojsonData, null, 2), {
        status: 200,
        headers: {
          'Content-Type': 'application/geo+json',
          'Content-Disposition': `attachment; filename="${routeData.area_name.replace(/\s+/g, '_')}_route.geojson"`,
        },
      });
    }
  } catch (error) {
    console.error('Error exporting route:', error);
    return NextResponse.json(
      {
        error: 'Failed to export route',
        details: error instanceof Error ? error.message : String(error),
      },
      { status: 500 }
    );
  }
}
